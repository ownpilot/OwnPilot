/**
 * Agent Builder
 *
 * LLM-guided agent creation through interactive Q&A.
 * Helps users create custom agents by asking clarifying questions
 * and generating appropriate configurations.
 */

import { randomUUID } from 'node:crypto';

// =============================================================================
// Types
// =============================================================================

/**
 * Agent configuration generated by the builder
 */
export interface GeneratedAgentConfig {
  id: string;
  name: string;
  emoji: string;
  category: string;
  description: string;
  systemPrompt: string;
  tools: string[];
  dataAccess: string[];
  triggers: {
    keywords: string[];
    description: string;
  };
  config: {
    maxTokens: number;
    temperature: number;
    maxTurns: number;
    maxToolCalls: number;
  };
}

/**
 * Builder question
 */
export interface BuilderQuestion {
  id: string;
  question: string;
  type: 'text' | 'select' | 'multiselect' | 'confirm';
  options?: Array<{ value: string; label: string; description?: string }>;
  required: boolean;
  default?: string | string[] | boolean;
}

/**
 * Builder answer
 */
export interface BuilderAnswer {
  questionId: string;
  value: string | string[] | boolean;
}

/**
 * Builder session state
 */
export interface BuilderSession {
  id: string;
  phase: 'gathering' | 'refining' | 'generating' | 'complete';
  answers: BuilderAnswer[];
  currentQuestionIndex: number;
  generatedConfig?: GeneratedAgentConfig;
  createdAt: string;
  updatedAt: string;
}

/**
 * LLM Provider for builder
 */
export interface BuilderLLMProvider {
  complete(messages: Array<{ role: string; content: string }>): Promise<string>;
}

/**
 * Available tools registry for builder
 */
export interface ToolInfo {
  id: string;
  name: string;
  description: string;
  category: string;
}

/**
 * Available data stores for builder
 */
export interface DataStoreInfo {
  id: string;
  name: string;
  description: string;
}

// =============================================================================
// Agent Builder
// =============================================================================

/**
 * Builder configuration
 */
export interface InteractiveAgentBuilderConfig {
  /** Available tools */
  availableTools?: ToolInfo[];
  /** Available data stores */
  availableDataStores?: DataStoreInfo[];
  /** Available categories */
  categories?: string[];
}

const DEFAULT_CATEGORIES = [
  'productivity',
  'finance',
  'development',
  'communication',
  'data',
  'education',
  'health',
  'entertainment',
  'custom',
];

const DEFAULT_DATA_STORES: DataStoreInfo[] = [
  { id: 'bookmarks', name: 'Bookmarks', description: 'Save and manage web bookmarks' },
  { id: 'notes', name: 'Notes', description: 'Personal notes and documents' },
  { id: 'finances', name: 'Finances', description: 'Financial records and expenses' },
  { id: 'memory', name: 'Memory', description: 'Long-term information storage' },
  { id: 'preferences', name: 'Preferences', description: 'User settings and preferences' },
  { id: 'calendar', name: 'Calendar', description: 'Events and schedules' },
];

/**
 * Base questions for agent creation
 */
const BASE_QUESTIONS: BuilderQuestion[] = [
  {
    id: 'purpose',
    question: 'What should this agent do? Describe its main purpose.',
    type: 'text',
    required: true,
  },
  {
    id: 'name',
    question: 'What would you like to name this agent?',
    type: 'text',
    required: true,
  },
  {
    id: 'category',
    question: 'What category best describes this agent?',
    type: 'select',
    options: DEFAULT_CATEGORIES.map((c) => ({
      value: c,
      label: c.charAt(0).toUpperCase() + c.slice(1),
    })),
    required: true,
    default: 'custom',
  },
  {
    id: 'personality',
    question: 'How should the agent communicate?',
    type: 'select',
    options: [
      { value: 'professional', label: 'Professional', description: 'Formal and business-like' },
      { value: 'friendly', label: 'Friendly', description: 'Warm and approachable' },
      { value: 'concise', label: 'Concise', description: 'Brief and to the point' },
      { value: 'detailed', label: 'Detailed', description: 'Thorough explanations' },
    ],
    required: true,
    default: 'friendly',
  },
  {
    id: 'dataAccess',
    question: 'What personal data should this agent be able to access?',
    type: 'multiselect',
    options: DEFAULT_DATA_STORES.map((d) => ({
      value: d.id,
      label: d.name,
      description: d.description,
    })),
    required: false,
  },
  {
    id: 'autonomous',
    question: 'Should this agent work autonomously (perform actions without confirmation)?',
    type: 'confirm',
    required: true,
    default: true,
  },
];

/**
 * Agent Builder - LLM-guided agent creation
 */
export class InteractiveAgentBuilder {
  private readonly config: InteractiveAgentBuilderConfig;
  private readonly sessions = new Map<string, BuilderSession>();
  private llmProvider?: BuilderLLMProvider;

  constructor(config: InteractiveAgentBuilderConfig = {}) {
    this.config = {
      availableTools: config.availableTools ?? [],
      availableDataStores: config.availableDataStores ?? DEFAULT_DATA_STORES,
      categories: config.categories ?? DEFAULT_CATEGORIES,
    };
  }

  /**
   * Set LLM provider
   */
  setLLMProvider(provider: BuilderLLMProvider): void {
    this.llmProvider = provider;
  }

  /**
   * Set available tools
   */
  setAvailableTools(tools: ToolInfo[]): void {
    this.config.availableTools = tools;
  }

  /**
   * Start a new builder session
   */
  startSession(): BuilderSession {
    const session: BuilderSession = {
      id: randomUUID(),
      phase: 'gathering',
      answers: [],
      currentQuestionIndex: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    this.sessions.set(session.id, session);
    return session;
  }

  /**
   * Get current session
   */
  getSession(sessionId: string): BuilderSession | null {
    return this.sessions.get(sessionId) ?? null;
  }

  /**
   * Get current question
   */
  getCurrentQuestion(sessionId: string): BuilderQuestion | null {
    const session = this.sessions.get(sessionId);
    if (!session || session.phase !== 'gathering') return null;

    const questions = this.getQuestions();
    if (session.currentQuestionIndex >= questions.length) return null;

    return questions[session.currentQuestionIndex] ?? null;
  }

  /**
   * Get all questions
   */
  getQuestions(): BuilderQuestion[] {
    // Build tool selection question dynamically
    const toolQuestion: BuilderQuestion = {
      id: 'tools',
      question: 'What capabilities should this agent have? Select the tools it needs.',
      type: 'multiselect',
      options: (this.config.availableTools ?? []).map((t) => ({
        value: t.id,
        label: t.name,
        description: t.description,
      })),
      required: false,
    };

    return [...BASE_QUESTIONS, toolQuestion];
  }

  /**
   * Submit an answer
   */
  submitAnswer(sessionId: string, answer: string | string[] | boolean): {
    success: boolean;
    nextQuestion?: BuilderQuestion;
    complete?: boolean;
    error?: string;
  } {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return { success: false, error: 'Session not found' };
    }

    const questions = this.getQuestions();
    const currentQuestion = questions[session.currentQuestionIndex];
    if (!currentQuestion) {
      return { success: false, error: 'No current question' };
    }

    // Validate required
    if (currentQuestion.required && !answer) {
      return { success: false, error: 'This question is required' };
    }

    // Store answer
    session.answers.push({
      questionId: currentQuestion.id,
      value: answer,
    });

    session.currentQuestionIndex++;
    session.updatedAt = new Date().toISOString();

    // Check if complete
    if (session.currentQuestionIndex >= questions.length) {
      session.phase = 'generating';
      return { success: true, complete: true };
    }

    return {
      success: true,
      nextQuestion: questions[session.currentQuestionIndex],
    };
  }

  /**
   * Generate agent configuration from answers
   */
  async generateConfig(sessionId: string): Promise<{
    success: boolean;
    config?: GeneratedAgentConfig;
    error?: string;
  }> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return { success: false, error: 'Session not found' };
    }

    if (session.phase !== 'generating') {
      return { success: false, error: 'Session not ready for generation' };
    }

    // Extract answers
    const answers = new Map(session.answers.map((a) => [a.questionId, a.value]));

    const purpose = (answers.get('purpose') as string) ?? '';
    const name = (answers.get('name') as string) ?? 'Unnamed Agent';
    const category = (answers.get('category') as string) ?? 'general';
    const personality = (answers.get('personality') as string) ?? 'helpful';
    const dataAccess = (answers.get('dataAccess') as string[]) ?? [];
    const tools = (answers.get('tools') as string[]) ?? [];
    const autonomous = (answers.get('autonomous') as boolean) ?? false;

    // Generate ID from name
    const id = name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');

    // Generate system prompt
    const systemPrompt = await this.generateSystemPrompt(
      name,
      purpose,
      personality,
      tools,
      dataAccess
    );

    // Generate emoji
    const emoji = this.selectEmoji(category, purpose);

    // Generate trigger keywords
    const keywords = this.extractKeywords(purpose);

    const config: GeneratedAgentConfig = {
      id,
      name,
      emoji,
      category,
      description: purpose.slice(0, 200),
      systemPrompt,
      tools,
      dataAccess,
      triggers: {
        keywords,
        description: purpose,
      },
      config: {
        maxTokens: 4096,
        temperature: personality === 'professional' ? 0.3 : 0.7,
        maxTurns: autonomous ? 50 : 25,
        maxToolCalls: autonomous ? 200 : 100,
      },
    };

    session.generatedConfig = config;
    session.phase = 'complete';
    session.updatedAt = new Date().toISOString();

    return { success: true, config };
  }

  /**
   * Generate system prompt using LLM or template
   */
  private async generateSystemPrompt(
    name: string,
    purpose: string,
    personality: string,
    tools: string[],
    dataAccess: string[]
  ): Promise<string> {
    // If LLM available, use it for better prompts
    if (this.llmProvider) {
      try {
        const prompt = `Generate a system prompt for an AI agent with these characteristics:

Name: ${name}
Purpose: ${purpose}
Personality: ${personality}
Available tools: ${tools.join(', ') || 'none'}
Data access: ${dataAccess.join(', ') || 'none'}

Generate a clear, focused system prompt that:
1. Defines the agent's role and expertise
2. Lists its capabilities
3. Sets the communication style
4. Includes any specific rules or guidelines

Return ONLY the system prompt, no explanations.`;

        const response = await this.llmProvider.complete([
          { role: 'user', content: prompt },
        ]);

        if (response && response.length > 50) {
          return response;
        }
      } catch {
        console.warn('[InteractiveAgentBuilder] LLM generation failed, using template');
      }
    }

    // Template-based generation
    const personalityText = {
      professional: 'Communicate in a professional, business-like manner.',
      friendly: 'Be warm, approachable, and conversational.',
      concise: 'Keep responses brief and to the point.',
      detailed: 'Provide thorough explanations and details.',
    }[personality] ?? '';

    const toolsText =
      tools.length > 0
        ? `\n\n## Capabilities\nYou have access to these tools: ${tools.join(', ')}`
        : '';

    const dataText =
      dataAccess.length > 0
        ? `\n\n## Data Access\nYou can access: ${dataAccess.join(', ')}`
        : '';

    return `You are ${name} - ${purpose}

${personalityText}

## Core Responsibilities
- ${purpose}
- Assist users effectively within your domain
- Ask clarifying questions when needed
- Provide accurate and helpful responses${toolsText}${dataText}

## Guidelines
1. Stay focused on your purpose
2. Be helpful and responsive
3. Use available tools when they help accomplish tasks
4. Respect user privacy and data`;
  }

  /**
   * Select appropriate emoji based on category and purpose
   */
  private selectEmoji(category: string, purpose: string): string {
    const lower = purpose.toLowerCase();

    // Check purpose keywords first
    if (lower.includes('bookmark')) return 'üîñ';
    if (lower.includes('note')) return 'üìù';
    if (lower.includes('finance') || lower.includes('money') || lower.includes('expense')) return 'üí∞';
    if (lower.includes('code') || lower.includes('program')) return 'üíª';
    if (lower.includes('write') || lower.includes('writing')) return '‚úçÔ∏è';
    if (lower.includes('research')) return 'üî¨';
    if (lower.includes('schedule') || lower.includes('calendar')) return 'üìÖ';
    if (lower.includes('email') || lower.includes('message')) return 'üìß';
    if (lower.includes('learn') || lower.includes('study')) return 'üìö';
    if (lower.includes('health') || lower.includes('fitness')) return 'üí™';
    if (lower.includes('travel')) return '‚úàÔ∏è';
    if (lower.includes('recipe') || lower.includes('cook')) return 'üë®‚Äçüç≥';
    if (lower.includes('music')) return 'üéµ';
    if (lower.includes('movie') || lower.includes('video')) return 'üé¨';

    // Fall back to category
    const categoryEmojis: Record<string, string> = {
      productivity: '‚ö°',
      finance: 'üí∞',
      development: 'üíª',
      communication: 'üí¨',
      data: 'üìä',
      education: 'üìö',
      health: '‚ù§Ô∏è',
      entertainment: 'üéÆ',
      custom: 'ü§ñ',
    };

    return categoryEmojis[category] ?? 'ü§ñ';
  }

  /**
   * Extract keywords from purpose
   */
  private extractKeywords(purpose: string): string[] {
    const words = purpose.toLowerCase().split(/\W+/);
    const stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
      'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
      'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
      'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'this',
      'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they',
      'my', 'your', 'his', 'her', 'its', 'our', 'their', 'me', 'him', 'us',
      'them', 'what', 'which', 'who', 'whom', 'when', 'where', 'why', 'how',
    ]);

    return words
      .filter((w) => w.length > 3 && !stopWords.has(w))
      .slice(0, 10);
  }

  /**
   * Delete a session
   */
  deleteSession(sessionId: string): boolean {
    return this.sessions.delete(sessionId);
  }

  /**
   * Quick create with minimal input
   */
  async quickCreate(
    purpose: string,
    name?: string
  ): Promise<{
    success: boolean;
    config?: GeneratedAgentConfig;
    error?: string;
  }> {
    const session = this.startSession();

    // Auto-answer questions
    const autoName = name ?? this.generateNameFromPurpose(purpose);

    session.answers = [
      { questionId: 'purpose', value: purpose },
      { questionId: 'name', value: autoName },
      { questionId: 'category', value: this.detectCategory(purpose) },
      { questionId: 'personality', value: 'friendly' },
      { questionId: 'dataAccess', value: this.suggestDataAccess(purpose) },
      { questionId: 'autonomous', value: true },
      { questionId: 'tools', value: this.suggestTools(purpose) },
    ];

    session.phase = 'generating';

    return this.generateConfig(session.id);
  }

  /**
   * Generate name from purpose
   */
  private generateNameFromPurpose(purpose: string): string {
    const words = purpose.split(/\W+/).slice(0, 3);
    return words.map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ') + ' Agent';
  }

  /**
   * Detect category from purpose
   */
  private detectCategory(purpose: string): string {
    const lower = purpose.toLowerCase();

    if (lower.includes('finance') || lower.includes('money') || lower.includes('expense') || lower.includes('budget')) {
      return 'finance';
    }
    if (lower.includes('code') || lower.includes('program') || lower.includes('develop')) {
      return 'development';
    }
    if (lower.includes('learn') || lower.includes('study') || lower.includes('teach')) {
      return 'education';
    }
    if (lower.includes('email') || lower.includes('message') || lower.includes('chat')) {
      return 'communication';
    }
    if (lower.includes('task') || lower.includes('schedule') || lower.includes('organize')) {
      return 'productivity';
    }
    if (lower.includes('data') || lower.includes('analyze') || lower.includes('report')) {
      return 'data';
    }

    return 'custom';
  }

  /**
   * Suggest data access based on purpose
   */
  private suggestDataAccess(purpose: string): string[] {
    const lower = purpose.toLowerCase();
    const access: string[] = [];

    if (lower.includes('bookmark') || lower.includes('save') || lower.includes('link')) {
      access.push('bookmarks');
    }
    if (lower.includes('note') || lower.includes('document')) {
      access.push('notes');
    }
    if (lower.includes('finance') || lower.includes('expense') || lower.includes('money')) {
      access.push('finances');
    }
    if (lower.includes('remember') || lower.includes('memory')) {
      access.push('memory');
    }
    if (lower.includes('schedule') || lower.includes('calendar') || lower.includes('event')) {
      access.push('calendar');
    }

    return access;
  }

  /**
   * Suggest tools based on purpose
   */
  private suggestTools(purpose: string): string[] {
    const lower = purpose.toLowerCase();
    const tools: string[] = [];
    const available = new Set((this.config.availableTools ?? []).map((t) => t.id));

    // Map keywords to tools
    const toolMappings: Array<{ keywords: string[]; tools: string[] }> = [
      { keywords: ['bookmark', 'save url', 'link'], tools: ['save_bookmark', 'search_bookmarks', 'fetch_web_page'] },
      { keywords: ['note', 'write', 'document'], tools: ['save_note', 'search_notes'] },
      { keywords: ['expense', 'finance', 'money', 'budget'], tools: ['add_expense', 'query_expenses', 'expense_summary'] },
      { keywords: ['schedule', 'reminder', 'calendar'], tools: ['create_scheduled_task', 'list_scheduled_tasks'] },
      { keywords: ['file', 'read', 'document'], tools: ['read_file', 'write_file', 'list_directory'] },
      { keywords: ['web', 'fetch', 'http', 'api'], tools: ['http_request', 'fetch_web_page'] },
      { keywords: ['code', 'program', 'script'], tools: ['execute_javascript'] },
      { keywords: ['remember', 'memory'], tools: ['remember', 'recall'] },
    ];

    for (const mapping of toolMappings) {
      if (mapping.keywords.some((k) => lower.includes(k))) {
        for (const tool of mapping.tools) {
          if (available.has(tool) && !tools.includes(tool)) {
            tools.push(tool);
          }
        }
      }
    }

    // Always include basic tools
    const basicTools = ['get_current_time', 'calculate'];
    for (const tool of basicTools) {
      if (available.has(tool) && !tools.includes(tool)) {
        tools.push(tool);
      }
    }

    return tools;
  }
}

// =============================================================================
// Factory Functions
// =============================================================================

let _builder: InteractiveAgentBuilder | null = null;

export function getInteractiveAgentBuilder(): InteractiveAgentBuilder {
  if (!_builder) {
    _builder = new InteractiveAgentBuilder();
  }
  return _builder;
}

export function createInteractiveAgentBuilder(config?: InteractiveAgentBuilderConfig): InteractiveAgentBuilder {
  return new InteractiveAgentBuilder(config);
}
